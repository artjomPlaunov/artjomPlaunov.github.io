---
layout: post
title:  TCP/IP in OCaml Part 2 - Connecting two TUNS
date:   2025-05-02 12:06:35 -0400
categories: ocaml networking systems
tags: [ocaml, tun, tap, networking, packet-parsing, systems-programming]
---

In this post, I will go over setting up two TUN devices and test out sending a packet from one device to the other. This will allow me to test my TCP stack locally on my machine.

## Why am I doing it this way? 

This is a bit of a meta section before I get into what I did. I'm new to networking, and instead of reading textbooks I thought it would be fun to do some hands on stuff. I didn't want a toy mock-up where packets are only sent via a pipe. I thought it would be cool to set up a very minimal but "real" network to send packets between two instances of my TCP stack. So this is an extension of part 1, where now I set up two TUN devices to be able to send packets between them, and that will be the basic infrastructure for coding my own TCP stack. I did reach some big hurdles trying this out, which I think is ultimately my own lack of knowledge with networking and what actually goes on in my computer. I still have a lot of questions, in particular about how the IP layer of my network stack really works. So going forward I'm also going be supplementing this project by reading the famous TCP/IP illustrated part 1 to backfill what is really going on. I plan to come back and edit any inaccuracies/vague spots in this series. 

This set up was a brute force style of learning, where I had 10 different parameters to tweak, and I finally landed on the right set of parameters to get my intended functionality. So I don't think this post will be as informative as my others, until I actually know more about networking and make some edits, and this paragraph disappears! 

## Set up

Now the goal is for me to have two separate user programs, each of which can run my TCP stack. In part 1 I showed how to set up a TUN device, so now I want to have two TUN devices, each one corresponding to a user program. My tun0 device from part 1 is the same. It is assigned to the address 10.0.0.1 on my local machine, and corresponds to the 10.0.0.0/24 subnet, i.e. anything sent to that address range will go to tun0. My new "peer" program also sets up a tun1 device, with address 10.0.1.0, and the subnet 10.0.1.0/24. Now the goal for me is to send a packet from the tun1 user space program to the tun0 device. I want the source to be something like 10.0.1.5, and the destination can be 10.0.0.2 (I can pick any source/destination combos that are on the correct subnets for the tun devices). 

I also need a packet to send. I had some initial IP code in part 1, but it is still very messy. I wont be cleaning it up until I actually get around to implementing a 3 way handshake. Right now I'm just testing out the infrastructure and trying to send a packet. So for now I used the python scapy package to create a simple, valid packet that I can send over: 

```python
from scapy.all import *

# Create an ICMP Echo Request packet
pkt = IP(src="10.0.1.5", dst="10.0.0.2")/ICMP(type=8, id=0x1234, seq=1)

# Save raw bytes to a file
with open("packet.bin", "wb") as f:
    f.write(bytes(pkt))
```

This just creates an ICMP packet with the source and destination that I want. Now here is my peer client test program that tries to write this packet: 

```ocaml
open Utils  (* Assumes you have Tun.create and run_command defined *)

let read_packet filename =
  let in_channel = open_in_bin filename in
  let packet = really_input_string in_channel (in_channel_length in_channel) in
  close_in in_channel;
  Bytes.of_string packet  (* Convert the string to bytes *)

let send_packet packet tun =
  
  (* Send the packet *)
  let _ = Tun.write tun packet in
  Printf.printf "Sent raw packet\n%!"

let main () =
  (* Set up the tunnel interface *)
  let tun = Tun.create "tun1" in
  run_command "sudo ip addr add 10.0.1.1/24 dev tun1";
  run_command "sudo ip link set tun1 up";

  (* Read the packet from file *)
  let packet = read_packet "packet.bin" in
  
  (* Loop to repeatedly send the packet *)
  Printf.printf "Sending packet repeatedly. Press Ctrl+C to stop.\n%!";
  while true do
    send_packet packet tun;
    Unix.sleep 1  (* Sleep for 1 second before sending the packet again *)
  done

let () = main ()
```

Here is where I hit my major roadblock. Even though the IPs for tun0 and tun1 are set up correctly: 

```
10.0.0.0/24 dev tun0 proto kernel scope link src 10.0.0.1 
10.0.1.0/24 dev tun1 proto kernel scope link src 10.0.1.1 
```

The packet was not getting forwarded, and read from, tun0. There are two things I had to do to fix this. Both seem very sketchy to do as someone with very little network knowledge, so this is the part I really want to backfill and make sure is secure. But for now, for local testing purposes, it seems fine to do. 

The first thing was to set my systems ip_forward flag to 1: 

```
sysctl -w net.ipv4.ip_forward=1
```

My understanding is that my kernel network stack is not in itself acting like a router. If it gets something from tun1, i.e. source 10.0.1.5, my understanding is that without the flag it says OK I don't care about this, and drops it. Setting the forward flag directs it to try to forward packets (This is the very vague part I hope to fill in). 

```
firewall-cmd --permanent --zone=trusted --add-interface=tun0
firewall-cmd --permanent --zone=trusted --add-interface=tun1
firewall-cmd --reload
```

The second thing was changing some firewall settings for tun0 and tun1. Again, this is the part I intend to write more about later. My main goal right now is just getting this working and writing a TCP stack! 

Now, the packets are sent. First I can tcpdump on both tun0 and tun1: 

```
tcpdump -i tun1
> 13:49:11.081257 IP 10.0.1.5 > 10.0.0.2: ICMP echo request, id 4660, seq 1, length 8

tcpdump -i tun0
> 13:49:51.094508 IP 10.0.1.5 > 10.0.0.2: ICMP echo request, id 4660, seq 1, length 8
```

Now I can look at the packet dump that I wrote for tun0 in part 1 of my tutorial, and voila, the packet is being received: 

```
=== Received ICMP Packet ===
IP Packet:
  Version: IPv4
  IHL: 5 (words)
  Total Length: 28 bytes
  Source: 10.0.1.5
  Destination: 10.0.0.2
  Payload Length: 8 bytes
  Protocol: ICMP
```

Now I can go on to implementing a 3 way handshake!

